---
layout: post
title: 百度面试题（市场部）
date: 2008-11-13
categories:
- nono
tags: []
status: publish
type: post
published: true
meta:
  edg_digg_count: '0'
  _edit_last: '1'
  _wp_old_slug: ! '%e7%99%be%e5%ba%a6%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%b8%82%e5%9c%ba%e9%83%a8%ef%bc%89'
  dsq_thread_id: '423325685'
---
<p><br />
在您进入百度在线笔试系统进行答题前，请仔细阅读并接受以下笔试规则：<br />
在线笔试分定时笔试和不定时笔试两种：<br />
定时笔试：您的可答题时间是笔试时长减去您初次成功登录进入笔试答题页面时距笔试开始已过的时间；<br />
例如，如果笔试时长是2小时，笔试20:00:00开始，您于20:20:00登录，您将有100分钟答题时间；<br />
不定时笔试：您的可答题时间是您初次成功登录进入笔试答题页面时开始后的笔试规定时长；例如，如果笔试时长是2小时，您于20:20:00登录，您的答题时间将在22:20:00结束；<br />
您可以在笔试开放的答题期间适当休息，但笔试系统不因您中断答题、关闭页面等而停止计时；<br />
请务必在笔试时间结束前提交您的答案，以保证我们能及时处理；<br />
请独立完成笔试的答题，但您可参考一切电子和书面的资料；<br />
在笔试系统开放期间请勿将题目以任何方式对外传播。<br />
百度商业应用产品市场部招聘笔试题目<br />
姓名 __________________ 毕业院校 _________________ 专业 _____________<br />
毕业时间 _____________ 手机 __________________ Email __________________<br />
申请职位（请打钩，可多选）：产品设计工程师 产品策略分析员<br />
欢迎你应聘百度商业应用产品市场部！请配合我们在60分钟内完成以下全部题目。请在答题纸上作答。草稿纸另外提供。请务必通读题目后进行答题。<br />
1. 题面：16，8，8，12，24，60，（）<br />
问题：请补充括号中的数字，并说明分析过程。提示，正确答案是以下数字中的某一个：300，240，180，120，80，40，20<br />
2. 题面：请阅读如下诗句中的一部分<br />
乳齿象的长牙，在激烈的争吵中猛烈的碰撞着<br />
最后都成了台球桌上来回滚动的球<br />
查理曼大帝那柄正义之剑<br />
已经斑驳布满了氧化铁，众人称它为铁锈<br />
灰熊那力大无比的拥抱，所有人都惧怕<br />
但如今它已成了毛毯<br />
问题：请体会诗句中表达的主题，并根据此主题，续写1~2个段落，并简要说明思路<br />
3. 题面：有一天你回家，拿出钥匙开门，却打不开门<br />
问题：请列出所有你能想到的可能的原因、检验方法、解决方案<br />
4. 题面：<br />
某日，三位武林人士约定比武以决定谁能作为百度公司的武侠形象代言人，他们分别是 李寻欢、段誉、韦小宝。<br />
他们的武功情况如下：李寻欢武功最高，命中率100%（即只要他出招，必定命中目标）；段誉次之，命中率50%；韦小宝较弱，命中率30%<br />
比武规则：为了以示公平，每一轮按照如下先后顺序出招&mdash;&mdash;韦小宝先出招，段誉第二个，李寻欢最后，轮到某人出招时，可以自由选择仍未出局的人为目标发招，被命中的人将成为败者并立即退出比武。按照这样的顺序循环进行，直到最后剩下1人为止，成为胜者<br />
问题：<br />
1、这三个人是三本武侠作品中的人物，请列出这三本武侠作品以及作者，并选取其中一本，用尽可能精炼的语言描述其故事梗概。<br />
2、假设这3人都是绝顶聪明的，即他们均按照最利于自己获胜的方式选择目标，那么请问，谁最有可能成为百度的武侠形象代言人？为什么？并至少描述前2轮他们各自采取的策略<br />
3、请简述你从本题中得到的启发<br />
5. 问题：请描述你的一项特长或爱好，并在答题纸上进行证明<br />
6. 问题：请列出你选择一份工作的最重要三条标准，简述原因<br />
7. 问题：1、请列出至少6种百度的产品，其中至少包含2项商业性的产品<br />
2、请挑选列出的商业性产品中的一种，用最精炼的语言描述该产品并简述你理解的该产品的核心内容（如果列不出商业性的，可以列非商业的，但会相应扣分）<br />
8. 题面：假设你现在已经毕业，给你1万元rmb作为本钱，要求在你所在的学校附近开展商业活动，在半年到一年的时间回收成本并实现利润最大化，并且可以在正常情况下（即不考虑天灾人祸）实现在2~3年内持续盈利。<br />
问题：请给出你的实现方案及思考本问题的思路，包括步骤、时间表、人员管理、成本控制，以及可能出现的风险点和应对方案等。请注意方案的完整性和合理性，不必拘泥于细节<br />
9. 问题：请思考并描述椅子的起源<br />
10. 题面：有人带了一枚硬币给博物馆馆长，希望卖给博物馆。硬币上面刻着铸造日期是&ldquo;公元前540年&rdquo;。馆长根本没有考虑是否购买，而是直接通知了警方。<br />
问题：请问这是为什么？并简述你的思考过程<br />
11. 题面：一个朋友给我讲述了如下故事，讲故事的人声称该故事是真实的：<br />
很久以前，一位美国男子和他的妻子去教堂参加活动，布道太长了，男子很困，于是趴在桌上睡着了，梦见了中国的义和团起义，梦中他被俘虏，被带到刽子手的断头台前面，恰巧在这时，他的妻子注意到他在打瞌睡，于是轻轻用随身携带的扇子的边缘敲了一下他的脖子。这位男子马上被吓死了。<br />
问题：请问这个故事是否是真实的，为什么？简述思考过程<br />
12. 题面：<br />
三个警察和三个囚徒共同旅行。一条河挡住了去路，河边有一条船，但是每次只能载2人。存在如下的危险：无论在河的哪边，当囚徒人数多于警察的人数时，将有警察被囚徒杀死。<br />
问题：请问如何确定渡河方案，才能保证6人安全无损的过河<br />
13. 题面：这里有一个等式： 2+7-118=129<br />
问题：这个等式不是一个有效的数学表达式，请在等式中画一条直线，使之变成有效的数学表达式。请注意至少提供3种方法<br />
14. 问题：你手头有10根火柴，需要摆出两个大小不同的正方形，必须用完所有火柴，请思考尽可能多的方案，并说明分析思路<br />
备注：答满10道题即为合格，多答可有酌情加分；2、5、6、7是公共必答题；除此以外，产品设计工程师必答题目8，产品策略分析师必答题目4<br />
百度商业应用产品市场部招聘笔试题目<br />
姓名 __________________ 毕业院校 _________________ 专业 _____________<br />
毕业时间 _____________ 手机 __________________ Email __________________<br />
申请职位（请打钩，可多选）：产品设计工程师 产品策略分析员<br />
欢迎你应聘百度商业应用产品市场部！笔试时间60分钟，另提供15分钟的可选延长。请在答题纸上作答。草稿纸另外提供。请务必通读题目后进行答题。<br />
15. 题面：1，-6，-9，0，45，198，（）<br />
问题：请补充括号中的数字，并说明分析过程。提示，正确答案是以下数字中的某一个：9，18，24，39，36，48，45，52，58，64，72，98，请说出推算第100个数字的方法<br />
16. 题面：日出江花红胜火<br />
问题：1、请补充该诗句在原诗中的下半句，并说明作者，诗名<br />
2、请自己写一句下半句，不允许使用原诗句，尽量保持对仗和结构，并简单说明思考过程<br />
17. 题面：<br />
某日，三位武林人士约定比武以决定谁能作为百度公司的武侠形象代言人，他们分别是 李寻欢、段誉、韦小宝。<br />
他们的武功情况如下：李寻欢武功最高，命中率a（即出招时命中目标的概率）；段誉次之，命中率b；韦小宝较弱，命中率c 且1&gt;a&gt;b&gt;c&gt;0<br />
比武规则：为了以示公平，每一轮按照如下先后顺序出招&mdash;&mdash;韦小宝先出招，段誉第二个，李寻欢最后，轮到某人出招时，可以自由选择仍未出局的人为目标发招，被命中的人将成为败者并立即退出比武。按照这样的顺序循环进行，直到最后剩下1人为止，成为胜者<br />
问题：<br />
1、这三个人是三本武侠作品中的人物，请列出这三本武侠作品以及作者，并选取其中一本，用尽可能精炼的语言描述其故事梗概。<br />
2、假设这3人都是绝顶聪明的，即他们均按照最利于自己获胜的方式选择目标，那么请问，谁最有可能成为百度的武侠形象代言人，每个人获胜的几率分别为多少？请给出推演方法和思路<br />
3、如果本题不进行计算，直接猜测答案，你将如何回答，为什么？<br />
18. 问题：<br />
1、著名的牛顿定律，都包含哪几个？请用精炼的语言描述他们，并针对每一个列出其在现实生活中的至少一项应用<br />
2、请选取牛顿定律中的一个或多个，谈谈对于你人生的启发<br />
19. 题面：这里有一个等式： 6+6-317=329<br />
问题：这个等式不是一个有效的数学表达式，请在其中画一条直线，使之变成有效的数学表达式。请注意至少提供5种方法<br />
20. 题面：<br />
靠近珠江码头的一只船上的一边船舷上悬吊着一架绳梯，绳梯一共有20个横档。自上而下数第11根横档刚刚浸入水中。已知江水以每小时1.2厘米的速度上涨。每两根横档之间的距离是8厘米，每根横档的厚度是0.75厘米。<br />
问题：请问24小时后浸入在水中的横档有几根？48小时后呢？<br />
21. 问题：请列出你选择一份工作的最重要三条标准，简述原因<br />
22. 题面：<br />
四个亲戚在一块度过了愉快的一天，尽管只有4人，但是他们却构成一个大家庭。这四个人中包括一个父亲和一个母亲、一个儿子和一个女儿、一个姐姐和一个弟弟（或一个哥哥和一个妹妹）、一个舅舅和一个舅妈、一个侄子和一个侄女、以及两个堂（或表）兄妹（或姐弟）。<br />
所有这些关系是发生在这4人之间（即如果某人是父亲，则他必是另外三人中某人或某些人的父亲，依次类推）。<br />
这4个人之间不存在其它的婚姻关系。<br />
问题：<br />
请分析这是为什么？并说明思考过程<br />
23. 问题：请最简洁的语言，精确的描述一种游戏规则<br />
24. 问题：1、请列出至少6种百度的产品，其中至少包含2项商业性的产品<br />
2、请挑选列出的商业性产品中的一种，用最精炼的语言描述该产品并简述你理解的该产品的核心内容（如果列不出商业性的，可以列非商业的，但会相应扣分）<br />
25. 题面：<br />
DONALD+GERALD=ROBERT<br />
上面等式中的每个字母都代表一个0~9的自然数<br />
问题：请分析并列出各个字母代表的数字<br />
26. 题面：某建筑师酷爱对称，他想在公园中种植4棵树，要求每棵树距离其它三棵树是一样的（距离的定义以树根与地面的接触部来计算）<br />
问题：请问该如何种植？请列出所有你想到的可能，并说明分析过程<br />
27. 题面：某另外一个建筑师，他想在公园中种植10棵树，要求种成5排，每排4棵，且每一排上相邻树的距离是一样的（距离的定义同样以树根与地面的接触部来计算）<br />
问题：请问该如何种植？请列出所有你想到的可能，并说明分析过程<br />
如果是12棵树，要求种成6排，同样每排4棵，该如何进行？<br />
28. 题面：两个对手玩一个游戏，桌上有标有1~9自然数的9张卡片，游戏规则是轮流从桌上的剩余卡片中取一张纸片，最先使得两人取出的卡片的数字之和等于15的人获胜。问题：请问是否存在先手必胜或者后手必胜的方法，如果有，请列出，并说明分析方法<br />
29. 题面：假如你是一家国内顶尖的笔记本电脑制造公司的负责新产品的项目经理，公司决定推出面向大学生的笔记本，以打开和开拓这方面的市场。<br />
问题：请提供你的项目方案及思考本问题的思路，包括步骤、时间表、人员管理、成本控制，以及可能出现的风险点和应对方案等。请注意方案的完整性和合理性，不必拘泥于细节<br />
30. 题面：<br />
三个警察和三个囚徒共同旅行。一条河挡住了去路，河边有一条船，但是每次只能载2人。存在如下的危险：无论在河的哪边，当囚徒人数多于警察的人数时，将有警察被囚徒杀死。<br />
问题：请问如何确定渡河方案，才能保证6人安全无损的过河<br />
备注：题目顺序与难度无关，答满10道题即为及格，多答可有加分；2、7、14、10、3、15必答<br />
&nbsp;<span style="color: #ff0000">------------------------------------------------------------------------------关于技术的</span></p>
<p>有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间。<br />
&nbsp;</p>
<p>&nbsp;</p>
<p>解法一：</p>
<p>最小11,最大就....32种走法,用程序模拟算比较简单,如果找算法规律.....就.....</p>
<p>正解！</p>
<p>每个蚂蚁对象维护自己的几个属性：<br />
time 在木头上走的时间<br />
pos&nbsp; 在木头上的坐标<br />
orientation 方向(-1 or 1)</p>
<p>recursion:<br />
1 所有蚂蚁走一步，矢量pos加1，time加1<br />
2 检查是否有蚂蚁在同一坐标上，如果有，将它们掉头<br />
3 检查是否有蚂蚁的坐标在[0,27]以外的外围，如果有，记下它的time值，然后这个蚂蚁出局<br />
4 repeat 1-3，直到所有蚂蚁出局。它们time的最大值就是一个解(一共有32个情况，32种解)。<br />
&nbsp;</p>
<p>解法二：</p>
<p>class FunnyAnt {<br />
class Ant {<br />
public final static int LEFT = 0;<br />
public final static int RIGHT = 1;<br />
int x;<br />
int direction;<br />
public Ant(int x, int direction) {<br />
this.x = x;<br />
this.direction = direction;<br />
}<br />
public void setDirection(int direction) {<br />
this.direction = direction;<br />
}<br />
public void move() {<br />
if (direction == LEFT) {<br />
x -= 1;<br />
} else {<br />
x += 1;<br />
}<br />
}<br />
public void switchDirection() {<br />
direction = (direction + 1) % 2;<br />
}<br />
public int getX() {<br />
return x;<br />
}<br />
public String getDirection() {<br />
return (direction == LEFT) ? &quot;Left&quot; : &quot;Right&quot;;<br />
}<br />
}<br />
public static void main(String[] args) {<br />
Vector v = new Vector();<br />
Vector timerV = new Vector();<br />
FunnyAnt fa = new FunnyAnt();<br />
int[] positions = {3, 7, 11, 17, 23};<br />
Ant ant = null;<br />
// list all conditions<br />
for (byte i = 0; i &lt; 32; i++) {<br />
// System.out.println(&quot;I :&quot; + i);<br />
int tempI = i;<br />
for (int j = 0; j &lt; 5; j++) {<br />
byte temp = (byte) (tempI &amp; 0x01);<br />
// System.out.println(&quot;Position Got :&quot; + temp);<br />
ant = fa.new Ant(positions[j], temp);<br />
v.addElement(ant);<br />
tempI = (byte) (tempI &gt;&gt; 1);<br />
}<br />
int timer = 0;<br />
while (v.size() &gt; 0) {<br />
ant = null;<br />
// move ants if out delete<br />
for (int k = 0; k &lt; v.size(); k++) {<br />
ant = (FunnyAnt.Ant) v.elementAt(k);<br />
ant.move();<br />
int x = ant.getX();<br />
if (x &lt;= 1 || x &gt;= 27) {<br />
v.removeElementAt(k);<br />
}<br />
}<br />
timer++;<br />
// check whether there is collide<br />
ant = null;<br />
for (int l = 0, lastX = -1; l &lt; v.size(); l++) {<br />
ant = (FunnyAnt.Ant) v.elementAt(l);<br />
if (lastX == ant.getX()) {<br />
((FunnyAnt.Ant) (v.elementAt(l))).switchDirection();<br />
((FunnyAnt.Ant) (v.elementAt(l - 1))).switchDirection();<br />
}<br />
lastX = ant.getX();<br />
}<br />
}<br />
timerV.addElement(new Integer(timer));<br />
v.removeAllElements();<br />
}<br />
int min = ((Integer) (timerV.elementAt(0))).intValue(), max = ((Integer) (timerV.elementAt(0))).intValue();<br />
Integer value = null;<br />
for (int i = 0; i &lt; timerV.size(); i++) {<br />
value = (Integer) timerV.elementAt(i);<br />
int x = value.intValue();<br />
if (x &lt; min) {<br />
min = x;<br />
}<br />
if (x &gt; max) {<br />
max = x;<br />
}<br />
}<br />
System.out.println(&quot;Max :&quot; + max + &quot; Min :&quot; + min);<br />
}<br />
}</p>
<p>&nbsp;</p>
<p>解法三：</p>
<p>&nbsp;</p>
<p><br />
//是否所有蚂蚁下杆，i为蚂蚁只数<br />
bool isOut(int *p,int i)<br />
{<br />
&nbsp;int j=-1;<br />
&nbsp;while(++j&lt;i)<br />
&nbsp;&nbsp;if(p[j]!=-1)<br />
&nbsp;&nbsp;&nbsp;return false;<br />
&nbsp;return true;<br />
}</p>
<p>//第i+1和第j+1位置蚂蚁是否碰头<br />
bool isEnt(int *p,int i,int j)<br />
{<br />
&nbsp; return (p[i]==p[j]&amp;&amp;p[i]!=-1&amp;&amp;p[j]!=-1)?true:false;<br />
}</p>
<p>int main(void)<br />
{<br />
&nbsp;&nbsp; //初始运动方向计数<br />
&nbsp;&nbsp; unsigned short int count=0;<br />
&nbsp;&nbsp; //a[0..4]代表3cm,7cm,11cm,17cm,23cm的运动方向，false为向右<br />
&nbsp;&nbsp; bool a[5]={false,false,false,false,false};</p>
<p>&nbsp;&nbsp; unsigned short int i=1;<br />
&nbsp;&nbsp; //蚂蚁开始运动方向最多32(2的5次方)种<br />
&nbsp;&nbsp; for(count;count&lt;32;count++){<br />
&nbsp;&nbsp;&nbsp; //设置5只蚂蚁初始运动方向<br />
&nbsp;&nbsp;&nbsp; //打印出蚂蚁初始运动方向<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=0;j&lt;5;j++){<br />
&nbsp;&nbsp;&nbsp; //因为count总小于32,所以高21位总是0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[j]=count&amp;(i&lt;&lt;j);<br />
&nbsp;&nbsp; printf(&quot;%d &quot;,a[j]);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; printf(&quot;\n&quot;);<br />
&nbsp;&nbsp; //pos[0..4]代表蚂蚁初始位置，若第i只蚂蚁离开杆则pos[i-1]=-1<br />
&nbsp;&nbsp; int pos[5]={3,7,11,17,23};<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=1;<br />
&nbsp;&nbsp; //t为时间<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int t=1;t;t++){<br />
&nbsp;&nbsp;&nbsp; //蚂蚁下一秒位置<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=0;j&lt;5;j++){<br />
&nbsp;&nbsp;&nbsp; if(pos[j]!=-1){<br />
&nbsp;&nbsp;&nbsp;&nbsp; if(a[j])pos[j]++;<br />
&nbsp;&nbsp;&nbsp;&nbsp; else pos[j]--;<br />
&nbsp;&nbsp;&nbsp;&nbsp; //蚂蚁下杆<br />
&nbsp;&nbsp;&nbsp;&nbsp; if(pos[j]&lt;=0||pos[j]&gt;=27)pos[j]=-1;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; //看相邻两只蚂蚁是否碰头，碰头调转方向<br />
&nbsp;&nbsp; for(int s=0;s&lt;4;s++){<br />
&nbsp;&nbsp;&nbsp; if(isEnt(pos,s,s+1)){<br />
&nbsp;&nbsp;&nbsp;&nbsp; a[s]=!a[s];<br />
&nbsp;&nbsp;&nbsp;&nbsp; a[s+1]=!a[s+1];<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; //是否所有蚂蚁下杆<br />
&nbsp;&nbsp; if(isOut(pos,5)){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;count:%d\n&quot;,t);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; }<br />
&nbsp;&nbsp; return 0;<br />
}<br />
&nbsp;</p>
